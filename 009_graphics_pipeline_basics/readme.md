# Introduction

在接下来的几章中，我们将设置一个图形流水线(graphics pipeline)，并将其配置为绘制第一个三角形。 图形管道是将网格顶点(vertices)和纹理(textures)一直传输到渲染目标像素的操作序列。 下面是一个简化的概览：

![](vulkan_simplified_pipeline.svg)



输入汇编器(input assembler)会从您指定的缓冲区(buffer)中收集原始顶点(raw vertex)数据，还可能使用索引缓冲区(index buffer)来重复某些元素，而无需重复顶点数据本身。



顶点着色器(vertex shader)针对每个顶点运行，通常应用变换(transformations)将顶点位置从模型空间(model space)转换到屏幕空间(screen space)。 顶点着色器还将每个顶点的数据传递到流水线上。



细分着色器(*tessellation shaders*)允许你根据特定规则对几何体进行细分，以提高网格质量。 这通常用于使砖墙和楼梯等在离得比较近的时候看上去不那么平整的表面。



几何着色器(*geometry shader*)在每个基元（三角形、线、点）上运行，可以丢弃或输出比输入更多的基元。 这与细分着色器类似，但要灵活得多。 不过，由于除了英特尔的集成 GPU 外，大多数显卡的性能都不是很好，因此在当今的应用中使用得并不多。



光栅化(*rasterization*)阶段将基元(primitives)分解成片段(fragments)。 这些片段就是它们在帧缓冲(framebuffer)上填充的像素元素。 如图所示，任何落在屏幕外的片段都会被丢弃，顶点着色器输出的属性会在这些片段之间进行内插。 通常情况下，由于深度测试的原因，位于其他基元片段后面的片段也会被丢弃。



片段着色器(fragment shader)会对每个存活的片段进行调用，并决定将片段写入哪个帧缓冲区，以及写入哪些颜色和深度值。 它可以使用来自顶点着色器的插值数据（其中可能包括纹理坐标和照明法线等）来完成这项工作。



颜色混合(color blending)阶段将对映射到帧缓冲中相同像素的不同片段进行混合操作。 片段可以简单地相互覆盖、相加或根据透明度进行混合。



绿色的阶段为固定功能阶段。 您可以使用参数调整这些阶段的操作，但它们的工作方式是预定义的。



另一方面，橙色的阶段是可编程的，这意味着你可以将自己的代码上传到显卡，以准确应用你想要的操作。 例如，您可以使用片段着色器来实现从贴图、照明到光线追踪等任何操作。 这些程序可在多个 GPU 内核上同时运行，并行处理许多对象，如顶点和片段。



如果您以前使用过 OpenGL 和 Direct3D 等旧版 API，那么您就会习惯于使用 glBlendFunc 和 OMSetBlendState 等调用随意更改任何管道设置。 Vulkan 中的图形管道几乎完全不可更改，因此如果要更改着色器、绑定不同的帧缓冲器或更改混合函数，就必须从头开始重新创建管道。 这样做的缺点是，你必须创建许多管道，以代表你想在渲染操作中使用的所有不同状态组合。 不过，由于管道中的所有操作都是预先知道的，因此驱动程序可以更好地进行优化。



有些可编程阶段是可选的，取决于你打算做什么。 例如，如果只是绘制简单的几何图形，可以禁用细分和几何图形阶段。 如果只对深度值感兴趣，则可以禁用片段着色器阶段，它对阴影贴图的生成非常有用。



在下一章中，我们将首先创建将三角形显示在屏幕上所需的两个可编程阶段：顶点着色器和片段着色器。 混合模式、视口、光栅化等固定功能配置将在之后的章节中进行设置。 在 Vulkan 中设置图形流水线的最后一部分是指定输入和输出帧缓存。



创建一个 `createGraphicsPipeline` 函数，在 `initVulkan` 中 `createImageViews` 之后调用。 在接下来的章节中，我们将一直使用该函数。
